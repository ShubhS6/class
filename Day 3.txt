Assignment on PDCP layer

sequence number
header Compression
integrity Protection
ciphering


it is based on Rohc it is protocol to compress the header
ip packet is of size 40 byte dont consider much usefull

#include <iostream>

class PDCP {
private:
    int sequenceNumber;  // Sequence number counter

public:
    PDCP() : sequenceNumber(0) {}  // Constructor to initialize sequence number
    
    // Method to get the next sequence number
    int getNextSequenceNumber() {
        return sequenceNumber++;
    }
};

int main() {
    PDCP pdcpInstance;

    // Simulate sending packets with sequence numbers
    for (int i = 0; i < 5; ++i) {
        int sequenceNumber = pdcpInstance.getNextSequenceNumber();
        std::cout << "Sending packet with sequence number: " << sequenceNumber << std::endl;
    }

    return 0;
}














[11:51 AM] Abhijeet kumar
#include <iostream>

#include <vector>

#include <cstdint>
 
class PDCP_Session {

private:

    uint32_t TX_NEXT = 0;  // Next transmitting sequence number

    uint32_t RX_NEXT = 0;  // Next expected receiving sequence number
 
public:

    // Simulate sending a PDCP packet

    void send_packet() {

        std::cout << "Sending packet with SN: " << TX_NEXT << std::endl;

        TX_NEXT = (TX_NEXT + 1) % 4096;  // Assume 12-bit SN for example

    }
 
    // Simulate receiving a PDCP packet

    void receive_packet(uint32_t sn) {

        if (sn == RX_NEXT) {

            std::cout << "Received packet with SN: " << sn << " successfully.\n";

            RX_NEXT = (RX_NEXT + 1) % 4096;  // Update the expected SN

        } else {

            std::cout << "Error: Received packet with SN: " << sn << ", expected SN: " << RX_NEXT << std::endl;

            // Handle error: could involve sequence number correction, retransmission requests, etc.

        }

    }

};
 
int main() {

    PDCP_Session session;
 
    // Simulating a normal sequence

    session.send_packet();

    session.receive_packet(0);  // Correct sequence
 
    session.send_packet();

    session.receive_packet(1);  // Correct sequence
 
    // Introducing an error in sequence

    session.send_packet();

    session.receive_packet(3);  // Incorrect sequence
 
    return 0;

}

















#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/applications-module.h"
#include "ns3/point-to-point-module.h"
 
using namespace ns3;
 
class PDCP_Session : public Application {
private:
    uint32_t TX_NEXT = 0; // Next transmitting sequence number
    uint32_t RX_NEXT = 0; // Next expected receiving sequence number
 
public:
    PDCP_Session() {}
 
    static TypeId GetTypeId(void) {
        static TypeId tid = TypeId("PDCP_Session")
            .SetParent<Application>()
            .SetGroupName("Tutorial");
        return tid;
    }
 
    virtual void StartApplication() {
        Simulator::Schedule(Seconds(1.0), &PDCP_Session::SendPacket, this);
    }
 
    virtual void StopApplication() {}
 
    void SendPacket() {
        std::cout << "Sending packet with SN: " << TX_NEXT << std::endl;
        // Simulate immediate receipt of the packet
        ReceivePacket(TX_NEXT);
        TX_NEXT = (TX_NEXT + 1) % 4096; // Assuming 12-bit sequence number
        Simulator::Schedule(Seconds(1.0), &PDCP_Session::SendPacket, this);
    }
 
    void ReceivePacket(uint32_t sn) {
        std::cout << "Receiving packet with SN: " << sn << std::endl;
        if (sn == RX_NEXT) {
            std::cout << "Received packet with SN: " << sn << " correctly." << std::endl;
            RX_NEXT = (RX_NEXT + 1) % 4096;
        } else {
            std::cout << "Sequence error: Received SN " << sn << ", expected " << RX_NEXT << std::endl;
        }
    }
};
 
int main(int argc, char *argv[]) {
    CommandLine cmd;
    cmd.Parse(argc, argv);
 
    NodeContainer nodes;
    nodes.Create(2);
 
    PointToPointHelper pointToPoint;
    pointToPoint.SetDeviceAttribute("DataRate", StringValue("5Mbps"));
    pointToPoint.SetChannelAttribute("Delay", StringValue("2ms"));
 
    NetDeviceContainer devices;
    devices = pointToPoint.Install(nodes);
 
    InternetStackHelper stack;
    stack.Install(nodes);
 
    Ipv4AddressHelper address;
    address.SetBase("10.1.1.0", "255.255.255.0");
 
    Ipv4InterfaceContainer interfaces = address.Assign(devices);
 
    Ptr<PDCP_Session> pdcp = CreateObject<PDCP_Session>();
    nodes.Get(0)->AddApplication(pdcp);
    pdcp->SetStartTime(Seconds(1.0));
    pdcp->SetStopTime(Seconds(10.0));
 
    Simulator::Run();
    Simulator::Destroy();
 
    return 0;
}
